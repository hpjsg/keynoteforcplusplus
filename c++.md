memmove()函数的作用是：将n个字节从内存区域src复制到内存区域dest。内存区域可能重叠：复制发生时，就好像src中的字节首先被复制到一个不重叠src或dest的临时数组中，然后将字节从临时数组复制到dest。当src<dst<src+n时，memmove会从src的尾端向前拷贝n个字符，防止内容的覆盖。

## 智能指针
智能指针是C++11 引入的，用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。包含在头文件<memory>中，其中包括： 
（1）shared_ptr：它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。每新增一个引用计数加1，当过期时引用计数减1。只有引用计数为0时，智能指针才会自动释放引用的内存资源。该引用计数的内存在堆上分配，指向相同资源的所有shared_ptr 共享“引用计数管理区域”，并采用原子操作保证该区域中的引用计数值被互斥的访问。

shared_ptr的一个最大的陷阱是循环引用（A持有B的智能指针，B持有A的智能指针），会导致堆内存无法正确释放，从而导致内存泄漏。
（2）weak_ptr：为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，虽然不指向引用计数的共享内存，但是可以检测所管理的对象是否已经被释放，从而避免非法访问，expired接口。 
（3）unique_ptr：一种对资源具有独占性的智能指针，即一个对象资源只能同时被一个unique_ptr指向。 C++14引入了make_unique。

GC是判断从栈和静态区的对象引用为根（相当于指针），进行BFS遍历，如果无法访问到的对象就回收。

多线程下引用计数：指向相同资源的所有shared_ptr 共享“引用计数管理区域”，并采用原子操作保证该区域中的引用计数值被互斥的访问。
Shared_ptr的线程安全级别和内建类型/标准库相同，它的引用计数是线程安全无锁的（使用原子变量或原子操作），可以线程安全的实现对象释放。但是，shared_ptr这个对象本身不是线程安全的，可能在线程A中被reset/写入，在线程B中读它的值，而它有两个数据成员，这两个数据成员不能一起被原子的写/读。一个shared_ptr对象可以被多个线程读，两个shared_ptr对象可以可以被两个线程同时写。多个线程读写同一个shared_ptr对象需要加锁保护。

使用场景：当类T被shared_ptr<T>管理时，在类的成员函数中需要将当前的类对象作为参数传给其他函数的时候，就需要传递一个指向自身的shared_ptr。这里不宜使用this指针，同时也不能shared_ptr<this>（和其他的shared_ptr<T>没有指向同一个引用计数管理的对象，会出现重复析构的错误）。当要传递当前对象作为参数的函数是一个异步执行的函数时，shared_ptr可以确保当前对象在这个异步函数执行时还存活着，异步函数需要的对象的成员变量也是有效的。

enable_shared_from_this类持有一个weak_ptr对象。shared_from_this()函数使用这个weak_ptr(weak_this_)对象来构造一个临时的shared_ptr对象返回。每次调用根据相同的weak_ptr来构造临时shared_ptr等价于用一个shared_ptr来做拷贝。使用weak_ptr而不直接持有shared_ptr，是因为如果类里储存了一个指向自身的shared_ptr，那么这个shared_ptr的计数最少都会是1，也就是说，这个对象将永远不能析构，产生循环计数。

## 面向对象/虚函数
对象模型：
非静态数据成员被置于每一个类对象之中，静态数据成员和非静态函数成员存在对象之外。编译器位每一个类生成一个表格（virtual table）vtbl，表格里存储指向虚函数的指针。每个类对象被安排一个指针，指向vtbl，指针被称为vptr。vptr的设定由构造、拷贝、析构函数完成。虚函数表中有类的type_info。 

虚函数的作用：用于实行有效率的执行期绑定 虚基类的作用：用以实现多次出现在继承体系中的基类，有一个单一而被共享的实体。

一个包含纯虚函数的抽象类没有定义这个函数，在虚函数表的对应位置通常C++会提供一个特殊的函数，_pure_virtual_function_called(),输出“纯虚函数调用”（或者其他类似的语句），然后使程序崩溃。

调用纯虚函数错误：
在基类的构造函数里直接/间接调用纯虚函数
在基类的析构函数里直接/间接调用纯虚函数
使用悬挂指针调用虚函数：指针指向的对象被 delete析构：第一步，对象作为一个派生类对象，第二步，对象作为一个基类实例。 delete后内存可能保持不变，调用虚函数，此时vptr指向基类虚函数表，会调用纯虚函数。

C++ 中不能声明为虚函数的函数：
构造函数/友元函数（不是类成员）/普通函数/内联成员函数（编译期就要展开无法动态绑定）/静态成员函数(可以继承但是编译期确定，无法被重写。而且属于类，不属于对象)

构造函数不能使用虚函数：
1、虚函数的函数指针保存在类的vtbl表中，每个类对象的内存空间中有指针vptr指向vtbl表，从而在执行期调用正确的虚函数。Vptr指针在构造函数/复制构造函数中被设置的，所以构造函数无法被设计为虚函数。
2、虚函数的意义在与执行期的动态绑定，构造函数是用来初始化实例，不是对象的动态行为，没有必要使用虚函数。

析构函数使用虚函数：
防止内存泄漏。一般将基类的析构函数声明为虚。这样当删除基类指针指向的派生类对象时，会调用派生类的析构函数，将派生类申请的内存空间进行释放，然后再调用基类的析构函数。如果基类的析构函数非虚函数，那么只会调用基类的析构函数，导致派生类申请的空间得不到释放从而产生内存泄漏。

类型的空指针可以调用成员函数。类型的成员函数是所有对象所共享的。当程序被编译之后，成员函数地址就已确定。空指针也是可以调用普通成员函数，只不过此时的this指针指向空而已。空指针不能调用虚函数，不指向有效的对象，没有vptr找不到vtbl，没法调用虚函数。

虚函数：
根据实际的对象类型判断调用相应的重写函数方法，而不是根据指针类型。基类指针指向基类对象，就调用基类的函数方法。基类指针指向派生类就调用派生类的函数方法。
在设计上，可以把不同的派生类对象都当作基类来看，可以屏蔽不同派生类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。赋值之后，父类型的引用就可以根据当前赋值给它的子对象的特性以不同的方式运行。

1、开辟内存
第一步：构造最顶层的基类部分:a、让实例指向基类的虚函数表 b、构造基类实例成员变量 c、执行基类构造函数体
第二步：构造派生部分（递归的）a、让实例指向派生类的虚函数表 b、构造派生类实例成员变量 c、执行派生类构造函数体
析构时则是按相反的顺序：
第一步：析构派生部分（递归的）a、执行派生类析构函数体 b、析构派生类实例成员变量 c、设置vptr指向基类的虚函数表
第二步：析构基类部分（递归的）a、执行基类析构函数 b、析构基类实例成员变量 c、设置vptr
第三步：如果有虚基类，虚基类有析构函数，且当前讨论的这个类是最尾端的类，调用虚基类的析构函数。

构造函数的执行顺序：
1、开辟内存。
2、类的成员变量, 是按照类的定义中, 成员变量的声明顺序进行构造的. 且构造都早于类构造函数的函数体的执行。
3、初始化列表的顺序, 不影响成员变量构造顺序。
4、构造函数的函数体执行在类成员变量初始化之后，对于类类型成员。会先缺省构造类的类类型成员，然后在构造函数体中，调用拷贝赋值运算符，为它赋值。使用初始化列表，可以将这两个步骤合并成一个拷贝构造函数的调用。

* vptr的设置：在基类构造函数的调用之后，在程序员提供的代码及初始化成员列表中所列的成员变量初始化操作之前进行初始化。在基类构造函数调用之后才设置vptr，使得每次调用可以调用正确的虚函数。程序员提供的代码及初始化成员列表中的成员变量初始化可能调用了虚函数，所以需要在这之前设置vptr。
虚函数表指针在对象中的位置：
某些编译器会把vptr放置在class object的尾端，另一些编译器会把vptr放置在class object的首端。


* this指针，在对象内存分配之后，this指针就可以使用了。只是这时候对象的数据没有全部准备好。在初始化列表中，类的成员还没有全部完成初始化。在构造函数体内，类的成员还可能没有assignment赋值。

必须使用初始化列表：
1、当初始化一个引用成员时
2、当初始化一个常量成员时
3、当调用一个基类的构造函数，而它拥有一组参数时
4、当调用一个类类型成员的构造函数，而它拥有一组参数时
编译器会对初始化列表一一处理并可能重新排序，以反映出成员的声明顺序。它会安插一些代码到构造函数体内，并置于任何显示用户代码(explicit user code)之前

一般的实现方法是，如果一个类内含有一个或多个虚基类子对象，将被分割为2部分：一个不变区域和一个共享区域。
不变区域：不管后接如何衍化，总是拥有固定的offset，可以被直接存取。
共享区域：所表现的就是“虚基类子对象“，这一部分的数据的位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。
一般的布局策略是先安排好派生类的不变部分，然后再建立其共享部分。cfront编译器会在每一个派生类对象中安插一些指针，每个指针指向一个虚基类。要存取继承得来的虚基类成员。可以通过相关指针间接完成。

空类：编译器安插进一个char，使得类X的对象得以在内存中配置独一无二的地址。

## 关键字
const/inline/static/virtual/new/delete

多态：
1、静态多态：函数重载/模板 编译器确定调用函数类型
2、动态多态：虚函数 运行期动态绑定

重载和虚函数(重写)的区别：
1、重载函数名相同，函数的参数类型或者个数不同，c++编译函数在符号库中的名字不仅仅是函数名，还加上了参数类型。发生在一个类中。
2、重写是派生类中重新对基类中的虚函数重新实现。函数名和参数完全相同，只有函数体不同。发生在继承体系中。实现是通过虚函数表vtbl和对象的vptr指针实现。重写函数的访问修饰符可以不同
3、重载是静态多态，编译器编译期确定调用函数类型，虚函数是动态多态，运行期有效率的动态绑定。

重定义：也叫隐藏。子类重新定义父类中有相同名称的非虚函数，参数列表可以相同可以不同，会覆盖其父类的方法。

* new/malloc：
1、new/delete 是c++关键字，malloc/free是库函数
2、new申请内存时无需指定内存块的大小，编译器根据类型信息自行计算。malloc需要显示指出所需内存的大小
3、new分配内存成功，返回指向对象类型的指针。malloc内存分配成功返回void*,需要通过强制类型转换成所需的类型。
4、new内存分配失败抛出bad_alloc异常，malloc分配内存失败返回nullptr
5、new会先调用operator new函数，申请足够的内存(底层通常用malloc实现)。然后(placement new)调用类型的构造函数，初始化成员变量，最后返回自定义类型的指针。delete先调用析构函数，然后调用operator delete函数释放内存(底层通常用free实现)。malloc和free只能动态申请释放内存，无法做自定义类型的对象构造和析构工作。

* static的作用
c/c++ 共有：
1.隐藏：修饰全局变量时，只有同一源文件的函数可见。修饰函数时，函数只在同一文件中可见。当同时编译多个文件时，所有未加static的全局变量和函数都具有全局可见性。
2.静态生命期。修饰局部变量时，使局部变量具有静态的生命期。当程序首次执行到变量的声明处时被初始化，且只能初始化一次，以后再次执行到初始化处将跳过。普通局部变量存储在栈中，当函数运行结束后失效。静态变量和全局变量相同，存储在数据段中。函数调用结束后仍然在数据段中，只是出了作用域，不能在函数体外使用。

C++
用于修饰类的成员static
1.	修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例
2.	静态成员函数，可以访问静态成员，不能访问非静态成员。可以通过类名：：函数名调用。

const:
1、定义类型为常量，修饰的对象只能在定义的时候被初始化一次，不能被修改(函数参数/返回值/指针)。
2、const限定成员函数，函数体内this指针被const限制。const成员函数中只能调用其他const成员函数，不能调用非const成员函数。不能修改类的成员变量。 非const成员函数不能访问const对象的数据成员。
const类型变量可以通过类型转换const_cast转为非const类型

内联函数：使用内联代码来代替函数调用。编译时，编译器将内联函数体插入并取代每一处函数调用的地方，节省函数调用的时间成本，代价是程序会包含多个函数代码的副本。
使用方法：声明前加上inline/定义前加上inline/省略原型，将函数整个定义放在提供原型的地方（函数头和函数体代码）。
内联函数不能递归。对某些递归函数的内联扩展可能引起某些编译器的无穷编译。

在main之前调用函数：
静态类对象/全局类对象/创建调用构造函数会在main函数之前，因此如果想在main函数前执行功能可以放在全局或静态类的构造函数中，然后再main函数前创建对象调用相应构造函数。
在main之后调用的函数：
进程的终止处理程序，一个进程最多登记32个终止处理程序。调顺序与登记顺序相反，登记接口atexit(void*(func)void); 在main函数结束后exit时调用终止处理程序。

出现段错误的原因：
1、访问无效内存 对进程的虚拟地址空间中根本没有映射到物理地址空间的部分的访问，2、对有效的地址空间进行不符合权限的操作。 访问已经被释放的变量/写入内存的只读部分/使用未初始化内存/内存读写越界/

四种类型转换：
static_cast: 在隐式转换时有时编译器会有警告信息，但是显示转换(使用static_cast)就不会有。static_cast还会进行一些基础的类型检查，能在编译期发现错误。
reinterpret_cast:数据的二进制格式重新解释，它依赖机器
dynamic_cast: 继承体系中的安全向下转换。指向基类的指针转型为指向子类的指针或引用。会动用运行时信息（RTTI）来进行类型安全检查。被转换的类型必须是多态（即有虚函数）
const_cast：去除或添加const特性

## 内存序
volatile 关键字：
易变性：所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。
不可优化：“不可优化”特性。volatile告诉编译器，不要对这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。(非volatile变量可能被编译器优化掉，进行常量替换等)
顺序性：多线程中的顺序性要求。C/C++ Volatile变量与非Volatile变量间的操作顺序，有可能被编译器交换。C/C++ Volatile变量间，编译器是能够保证不交换顺序。但是cpu执行还是可能乱序的。同时，C/C++ Volatile关键词，并不能用于构建happens-before语义。
Java的Volatile也有这三个特性，但最大的不同在于：第三个特性，”顺序性”，Java的Volatile有很极大的增强，Java Volatile变量的操作，附带了Acquire与Release语义。
因此Java Volatile，能够用来构建happens-before语义。


多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。
std::memory_order_relax 没有同步或顺序制约，仅对此操作要求原子性

std::meory_order_release 当前线程中的读或写不能被重排到这行代码之后。与store联合使用。
std::memory_order_acquire 当前线程中读或写不能被重排到这行代码之前，常与load联合使用。

RA模型：线程A release写，线程B acquire读，一旦原子变量load完成，线程B可以看到线程A写到内存的所有东西。在release/acquire相同原子变量的线程间建立同步关系。
RC模型：
线程A release写，线程B consume读，一旦原子变量load完成，线程B中依赖load值的操作可以看到线程A写到内存的所有东西。在release和consume相同原子变量的线程间建立同步关系。
acquire/release 会影响到与真正变量无关的代码，对性能造成影响

读写的加强
std::memory_order_acq_rel：常与store连用，当前线程的读或写内存不能被重排到此存储前或后。所有release同一原子变量的线程的写入可见于修改之前，而且修改可见于其他acquire同一原子变量的线程。 (用于读-修改-写操作)
最强约束：
std::memory_order_seq_cst 以上约束加一个单独全序，其中所有线程以同一顺序观测到所有修改
## c++11新特性

## STL库
vector
连续内存空间，常规时间随机存取。非尾部插入和删除造成内存拷贝，线性复杂度。内存空间不足时，重新申请一块空间并进行内存拷贝，实现动态增长。
不同编译器，vector扩容大小不同。vs下是1.5倍，gcc下是2倍。使用2作为增长因子，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好。
释放空间：vector(vec).swap(vec);

list 双向链表，内存空间不连续。线性复杂度随机存取，高效的插入和删除。

deque是双向开口的连续线性空间，可以在头尾两端分别做元素的插入和删除操作。deque相比vector，允许常规时间对头端元素进行插入和删除操作，而且deque没有容量的概念，它是以动态的分段连续空间组合成，随时可以增加一段新的空间链接起来，没有空间预分配的概念。

deque采用一块所谓的map作为主控(中控器)。这里所谓的map是指一小块连续空间，其中每个元素都是一个指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。一旦map所提供的节点不足，就必须重新配置更大的一块map。

stack往往不被归类为容器，而被归类为容器适配器。以deque作为缺省情况下的stack底部结构。只有stack顶端的元素有机会被外界取用，stack不提供遍历功能，也不提供迭代器。指定其它容器作为stack的底层容器的方法：
stack<int,list<int> > istack; 只要提供了size(),empty(),back(),push_back(),pop_back()这几个接口就可以作为stack的底层容器。

queue STL以deque作为缺省情况下的queue底部结构。只有首部元素才有机会被外界取用，queue不提供遍历功能，也不提供迭代器。提供pop_front()接口。可以使用list。

priority_queue priority queue只有首部的元素有机会被外界取用。不提供遍历功能，也不提供迭代器。底层默认使用vector。需要支持随机访问。 push/pop 接口类似queue

标准关联容器：
set/map multiset/ultimap :RB tree
hash_set/hash_map hash_multiset/hash_multimap :hash_table 


set/hashset map/hashmap
set,map底层使用RBtree，hash_set/hash_map底层使用hashtable。
1.	RBtree有自动排序功能而hashtable没有
2.	Hashtable有些无法处理的型别double/string(除非用户为这些型别撰写hash function并定义==，RBtree只要对应型别的less<T>(往往调用operator <))

Set/map
1、底层使用RBtree实现，插入删除操作的时间复杂度是O(logn)
2、map存放键值对pair，同时拥有实值和键值，set元素的键值就是实值。map不允许两个元素有相同的键值，set不允许有两个相同的元素。
3、set值不允许通过迭代器修改，因为实值就是键值会影响排列。Set<T>：：iterator被定义为底层RBtree的const_iterator,杜绝任何写入操作。map不允许通过迭代器修改键值，但是可以修改元素的值。因此map的迭代器不是const_iterator(是RBtree::iterator,使用*或->返回 value& 或 value*,const_iterator返回 const value&,const value*，map中value为pair<const key,T>类型)。

map的[]运算符，将key作为下标去查找，并返回相应的值的引用。如果不存在这个key，将一个具有该关键码和值类型的默认值项插入这个map。find函数用关键码执行查找，找到了返回该位置的迭代器，如果不存在就返回end迭代器。

分配器：
allocator
deallocator
两级分配器：第一级直接使用malloc和free。第二级：大于128byte使用第一级分配器。小于使用free_list自由链表和内存池memory pool。维护了16个自由链表，负责16中小型区块的配置。(以8byte为间隔，从8-128byte的内存块)。若free-list中没有可用区块时，会从内存池中申请空间重新填充free-list。如果内存池剩余空间也不足，利用malloc()从heap中分配内存。


库其实就是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。目标文件(.o)通过链接生成可执行文件。
链接分为静态链接和动态链接。 对函数库的链接是放在编译时期完成的是静态链接。所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 程序在运行时，与函数库再无瓜葛，因为所有需要的函数已复制到相关位置。这些函数库被称为静态库，通常文件名为“ libxxx.a”的形式。

动态链接。 除了静态链接，也可以把对一些库函数的链接载入推迟到程序运行时期，这就是动态链接库（ dynamic link library）技术。 动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so。程序在运行时，会在 /usr/lib 和/lib等目录中查找需要的动态库文件。 若找到，则载入动态库，否则将提示错误而终止程序运行。 

1、动态链接库有利于进程间资源共享。运行的程序共享着同一个动态链接库，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。 如果有，则共享一个拷贝。 而静态链接库则不同，如果系统中多个程序都要调用某个静态链接库函数时，则每个程序都要将这个库函数拷贝到自己的代码段中，占用更大内存资源。
2、将一些程序升级变得简单。 用静态库，如果库发生变化，使用库的程序要重新编译； 使用动态库，只要动态库提供给该程序的接口没变，只要重新用新生成的动态库替换原来就可以了。
3、由于静态库在编译的时候，就将库函数装载到程序中去了，而动态库函数必须在运行的时候才被装载，所以程序在执行的时候，用静态库速度更快些。


traits 技巧：
算法中运用迭代器时，很可能会用到其相应类型。所谓相应类型，迭代器所指之物的类型便是其中之一。算法可以在函数体中使用迭代器所指之物的类型来定义变量，或作为算法的返回值。
C++没有typeof这种函数。
1、(需要定义变量时)利用函数模板的参数推导机制解决，引入一层间接性，算法func(Iter){func(Iter,*Iter)}作为对外接口，算法的所有逻辑另外封装在一个实现函数func_impl<Iter,T>()中，函数模板，一旦被调用，编译器就会自动进行参数推导，导出类型T。
2、(需要所指类型作为返回值时) 模板参数推导无法用于返回值，在iter类中内嵌类型声明(nested type) typename Iter::value_type

vector缺省使用alloc作为空间分配器


函数模板特化/偏特化：
特化：模板参数在某种特定类型下的具体实现称为模板特化，模板特化有时也被称为模板具体化。（并不是模板实例化）

偏特化 是模板特化的一种特殊情况，显示部分模板参数而非全部模板参数，或者指定模板参数的部分特性而非全部特性，也称为模板部分特化。偏特化是相对于全特化而言，指对所有的模板参数进行特化。

模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用。

调用优先级：全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。
```c++
// 一般化设计/针对迭代器
template<class I,class O>
struct testclass
{
    testclass(){cout<<"I,O"<<endl;}
}

//类模板偏特化
template<class T>
struct testclass<T*,T*>
{
    testClass(){cout<<“T*，T*”<<endl;}
}

template<class T>
struct testclass<const T*,const T*>
{
    testClass(){cout<<“const T*，const T*”<<endl;}
}
```c++
调用时 testclass<Inputiterator,Outputierator>ojb 调用1；
testclass<int*,int*> 调用2；
testclass<cosnt int*,int*>调用3；

copy为例：
泛化版本针对使用迭代器作为参数：
copy_dispatch：traits方法获得迭代器类型，根据不同迭代器类型，实现不同版本。从first拷贝到last，如果使用randomaccessiterator循环判断是n = last-first;n>0;--n速度较快。如果是inputiterator 循环判据是first != last判断速度较慢。

偏特化版本针对使用指针作为参数：
copy_dispatch type_traits<T>是否有non_trivial_assignment_operator,如果没有memmove