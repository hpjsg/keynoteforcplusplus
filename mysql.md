# Mysql

## B-Tree和B+Tree（https://www.cnblogs.com/zhzhang/p/5693778.html）

m阶B树是一棵m路平衡搜索树，每个节点中最多m-1个有序关键码，每个关键码会有一个对应于大于它和小于它的子节点。
B+树和B树的不同在于，B+树的叶子节点存放了所有的关键码以及对应记录存放的指针(索引+数据)，所有上层非叶子节点只存储关键码(索引)，搜索时一定要搜索到叶子节点为止，不会在非叶子节点命中。(非叶子节点的关键码会在刚大于它的叶子节点中的最小位置复写，非叶子节点没有存放记录会更小，可以更好利用缓存。每个节点都对应一页，B+树对应结构更矮)；同时，为叶子节点增加了链指针，由于链表中的关键码是有序的，方便进行范围查询。  

## 存储引擎MyISAM和Innodb

* 存储方式：Innodb采用主键聚簇索引，其余非聚簇索引的形式。MyISAM采用非聚簇索引，数据和索引放在不同的文件中。  
* 并发：Innodb采用行级锁(MVCC)实现非阻塞读，MyISAM没有行级锁，对整张表加锁，对读读使用共享锁，对写使用排它锁。  
* 事务：Innodb支持事务，也就支持4种隔离度；MyISAM不支持事务。  
* 奔溃恢复：Innodb相比MyISAM，奔溃后数据损坏的可能性更小，并且恢复也更快。  

## Innodb中的事务与并发控制  

事务是一个操作序列，具有ACID性:  

* 原子性A  
  一个事务不能再分割，事务中的操作要么全部执行成功要么全部失败  
* 一致性C  
  一致性是指在事务开始之前和结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
* 隔离性I  
  不同事务间具有隔离级别。当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。  
* 持久性D  
  提交的事务就会永久生效。

事物之间的相互影响：
* 脏读
一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的。
* 不可重复读
一个事务范围内，两个相同的查询返回了不同的数据
* 幻读
若事务A在范围内查询，事务B在范围内插入一行并提交，事务A再次在该范围内查询，会产生幻行
* 丢失更新
两个事务同时读取同一条记录，A先修改记录，B也修改记录，B提交数据后B的修改结果覆盖了A的修改结果

隔离级别：

* 未提交读 READ UNCOMMITTED  
  事务中的修改即使没有提交也会对其他事务可见。会出现以上四种问题  
* 提交读 READ COMMITTED(RC)  
  只读取其他事务已经提交的数据。解决了脏读。
* 可重复读(MySQL默认) REPEATABLE READ(RR)  
  可重复读解决了不可重复读的问题，一个事务中相同的查询得到的结果是相同的。但是理论上会出现幻读，若事务A在范围内查询，事务B在范围内插入一行并提交，事务A再次在该范围内查询，会产生幻行。但MySQL通过MVCC解决了幻读问题。  
* 可串行化 SERIALIZABLE  
  强制事务的串行执行，对读的每行都上锁。  

锁：  

* 行锁：  
  修改某一行数据时施加的锁(隐式获取)，粒度较小。事务中使用两阶段锁，即随时可以获得锁，但是统一在commit或rollback时释放锁。如在事务A中update某一行，未提交前，在另一个事务B中update这行会阻塞。  
  select for update / select lock in shared mode则显式的获取锁，应当尽量避免使用，select for update总能通过修改update语句来避免（使用一个sql语句完成）。  
  InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。  
  不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。  
  只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。  

* MVCC多版本并发控制(行级锁)：(https://blog.csdn.net/SnailMann/article/details/94724197)  
  MySQL中的MVCC实际只实现非阻塞读，即读读，读写不阻塞，而写写是阻塞的，使用排它锁。  
  innodB给每个表多添了两列，一列是DATA_TRX_ID，表示更新这列的事务ID，另一列是ROLL_BACK_PTR，指向该行数据的回滚版本。存储引擎维护一个全局的活动事务的列表trx_ids，每次新开一个事务给它分配一个递增ID。当执行select时，会复制一份当前的活动事务列表，以及当前已经分配的最大事务编号，作为READ_VIEW。如果某行的DATA_TRX_ID小于活动事务列表的最小事务，说明是在事务开始前就已经提交的，可以读取；如果大于已经分配的最大事务，说明是在select后才提交的，是不可见的，不可以读取；如果在最小未提交和最大分配之间，则看是否在活动事务列表中，在的话说明还没有提交，不可见，不在说明已经提交了，可见。不可见的数据从回滚版本的历史版本开始寻找前一个版本，直到符合可见要求。

  RR和RC的区别在于，RC在每次select时都会产生一次READ_VIEW(复制当前活动事务，已经分配的最大事务编号，最小未提交事务编号)，从而实现已提交就能可见，从而也就有不可重复读的问题。而RR在一个事务中只使用第一次select语句产生的READ_VIEW，从而能保证可以重复读。

* 间隙锁(next-key locking):(https://www.cnblogs.com/kramer/p/10969269.html)
  当前读：读取的是记录数据的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
  快照读：读取的是记录数据的可见版本，像不加锁的select操作就是快照读，即不加锁的非阻塞读
  实际上间隙锁(gap lock)只是锁住区间，next-key locking是gap lock + record lock。next-key locking是为了解决幻读问题。MVCC已经可以保证一个事务中的select不会产生幻读，同时也不会阻塞其他事务对区间的insert/update等操作，但是这只是保证了"快照读"不会产生幻读。但是MVCC无法对写(也就是"当前读")生效，如果事务A要在区间内insert，事务B也要在这个区间内update，普通的RR原则上B是可以感知到A的修改的(也就是B发现update的数据行多了A新插入的一行)，也就是"当前读"产生了幻读，因为MVCC和行锁不能消除幻读的影响。对当前读，MySQL不仅对行上锁，在进行"当前读"时给索引的对应区间也上锁(gap lock)，通过间隙锁来锁住目标记录可能出现的位置，从而不会出现幻读。 

* [MVCC与乐观锁](<https://www.zhihu.com/question/27876575>)(如何将乐观锁用于数据库？)  
  MVCC利用基于快照的多版本方式处理的是读写阻塞的问题。对于写写问题，会和常见的悲观锁如2PL或者乐观锁配合，比如MVCC+2PL或MVCC+OCC，在mysql中使用MVCC+2PL的策略，也就是写写是阻塞的。  
  乐观并发控制一般是基于验证的，通过对额外的列进行验证和原子修改来进行并发控制。比如可以使用隐藏列version或是时间戳timestamp，在写时先保存一下当时的version或timestamp，写在私有临时区域中写，写完之后验证是否满足隔离度，version或是timestamp能否compareAndSet成功，如果满足就写commit写数据，否则就回滚。

  上边说的是数据库底层的并发控制。  
  还有一个业务场景中会出现先select一个字段，然后对这个字段进行复杂的逻辑处理计算一个新值，然后update这个新值。由于select阶段是基于快照不阻塞的，因此虽然整个事务已经会满足MYSQL的隔离度，但可能出现业务上不希望出现的覆盖修改。首先尽量避免这么写，如果没办法调整为单条update语句解决的话，一种方法是显式的加select for update锁，但是这相当于扩大了锁的范围。另一种办法是，显式的增加一列冗余列如version或是timestamp，select时不加显式锁，在update的where中比较version是否被修改过了，如果和select时相同就写成功，不相同就写失败。这种方式有点乐观的思路，不扩大锁的范围，底层还是依赖数据库对写的并发控制(不论是加锁还是OCC)。  

  乐观体现在，访问数据时不提前加锁。在资源冲突不激烈的场合，用乐观锁性能较好。如果资源冲突严重，乐观锁的实现会导致事务提交的时候经常看到别人在他之前已经修改了数据，然后要进行回滚或者重试。

## [LOG与持久性D](<https://zhuanlan.zhihu.com/p/98778890>)  

MySQL中常见的Log有RedoLog和BinLog。  

* RedoLog  
  当修改一条记录时，修改的是内存值，此时形成了脏页。如果要把内存值同步修改到磁盘中，太慢了(因为记录是随机读写/redolog是顺序读写，而且做了优化)。这时写的是RedoLog，RedoLog存储的是页的物理变化。

* BINLOG  
  RedoLog是innodb存储引擎层面实现的，BINLog是MYSQL服务器层面实现的。也就是说，RedoLog只在使用了innodb作为存储引擎的MySQL上才有，而 binlog，只要你是 MySQL，就会有。  
  和RedoLog不同，BinLog记录的是数据的逻辑变化，近似的可以理解为记录了SQL语句(类似Redis里的AoF?)  
  MySQL通过BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制（主从复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）
  MySQL 的恢复机制有以下特点：  
  一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。  
  二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。  


* 联系  
  RedoLog是用来在宕机或掉电这种物理情况下保障crash recovery的，也即靠它实现ACID的D。  
  BinLog是用来人工恢复某个时间的状态(比如不小心清空了库，想要恢复)，以及用来主从同步。   

## 索引  
在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。数据库使用索引以找到特定值，然后通过指针找到包含该值的数据行。
### 表的数据完整性——约束

* 非空约束 not null  
* 主键约束 primary key  
* 外键约束 一个表(子表)的字段必须依赖另一个表(父表)的字段  
  如表A中a字段引用B表中b字段作为外键，那么a字段的值必须要在b字段中存在。对于修改约束b而言有多种策略，restrict策略：不允许修改b的值；cascade：同步更新，修改b也得修改a；set null：修改b将对应a设为NULL。  
  外键使得查询需要额外的查询另一张表，修改时也需要额外的另一张表的锁，这就使得可能存在死锁。  
  如果时刻需要保证两张表的某个字段的一致性，外键可能比在应用程序中实现更高效；然而如果只是为了做约束，那么不使用外键，在应用程序中进行校验更合适。  
* 检查约束 check(expr)  
* 唯一约束 unique key  

### 匹配原则  

可用匹配：  

* 全值匹配：完全符合索引进行等式匹配  
* 最左匹配：只使用索引的左边列  
* 匹配列前缀：可以只匹配某列的最左前缀(如char索引匹配以A开头的记录)，需要满足最左匹配  
* 精确匹配某一列，在范围匹配某一列
* 覆盖索引：如果要查询的内容完全被索引包含了，那么就不用再去回表

索引限制：  
必须最左匹配，如果有索引(A,B,C)那么A=,C=条件是只能用到索引里的A；当某个列使用范围查询时，右边的列都不能在使用索引，如A=,B>,C=那么C是用不了索引的。  

* 假设有独立索引A，索引B那么where A= ， B=能用到多少索引？原则上只能用A或B，但是MySQL可能做了优化，优化为类似 where A= Union All where B= and A<>来用到两个索引。  

* 组合索引的顺序，选择性大的放在前边(能筛去更多数据)  

### 聚簇索引  （https://www.jianshu.com/p/fa8192853184）

所谓聚簇索引是指数据行存放在索引的叶子节点中，并且同一个叶子页(默认16K)中数据行紧凑的存储在一起。这就使得对聚簇索引的搜索最终能直接获得整行的所有数据，不需要再另外寻址，速度更快。但是需要注意，插入新数据行或者索引被更新时，可能出现页分裂的问题。  

InnoDB默认对主键进行聚簇索引，如果没有显示定义主键，则会挑选一个unique索引，如果没有会隐式定义一个主键作为聚簇索引。其余二级索引的叶子节点存放的key值+主键值，因此二级索引需要两次查找，除非是覆盖索引的情况。  

MyISAM中每个索引的叶子节点存放数据行各自对应的物理位置，而不是聚簇索引那样的存储在一起(叶节点索引和同一个叶子中的数据行存在同一个物理页上)。  

InnoDB中主键常见的自增主键，能够使得每个数据行的插入都在前一行的后边，如果页满了，就写新的页，没有页分裂和页碎片，时间和空间的效率都很高。如果主键的值不顺序，非常随机，那么插入一个数据行到一个页中会强制移动插入位置后的所有数据行；此外，如果插入到一个已满的页中，会导致页分裂，出现页碎片，导致占用更多存储空间。  

### 覆盖索引  

如果一个二级索引(辅助索引)包含了某次查询需要的全部列，那么就可以不用回表查询(仅使用这个辅助索引就可，不需要再聚簇索引得到完整数据行)。注意二级索引还有隐含的列信息(主键列)。注意仍旧需要符合索引匹配原则，比如匹配字符串的中段也没办法用索引，仍旧需要回表。  

### 使用索引进行排序  

假设存在索引(A,B,C)
若where A= Order by B desc，第一列A是常量，因此和Order的B合起来形成了最左匹配，可以用到索引。  
若where A> order by A,B，也可以用到索引，因为order的A，B符合最左匹配。  


乐观锁&悲观锁
悲观锁：
总是假设最坏的情况，每次去拿数据的时候都认为别的线程会修改，所以每次在拿数据的时候都会上锁，这样别的线程想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁：
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能