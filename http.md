## 概念
* URI 统一资源标识符：用字符串标识某一互联网资源
* URL 统一资源定位符：URI子集 资源的位置
报文 = 报文首部+空行+报文主体
* 请求报文：
报文首部=请求行+首部字段
请求行：方法+请求URI+协议版本
首部字段：请求首部字段+通用首部字段+实体首部字段
* 响应报文：
报文首部=状态行+首部字段
状态行：协议版本+状态码+原因短语
首部字段：响应首部字段+通用首部字段+实体首部字段


## 要点
* 长连接：只需要建立一次TCP连接就能进行多次HTTP通信 HTTP1.1开始默认长连接，客户端和服务器端通用首部字段connection:close断开

* pipeline:默认情况下，HTTP请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。pipeline是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

* cookie:
HTTP协议是无状态的，引入cookie来保存状态信息。cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。服务器发送的响应报文包含set-cookie字段，客户端得到响应报文后吧cookie内容保存到浏览器中。客户端下次再往该服务器发送请求时，从浏览器中取出cookie信息通过请求报文的cookie首部字段发送给服务器。(比如可以报用户的用户名和密码包装为cookie，不需要每次访问都登录了)

* session: web server引入session用于保存客户端信息。cookie将用户信息存储在用户浏览器中，session将用户信息存储在服务器端。 session的实现方法：1)URL重写。 Web Server在返回Response的时候，检查页面中所有的URL，包括所有的连接，和HTML Form的Action属性，在这些URL后面加上“;jsessionid=XXX”。 下一次，用户访问这个页面中的URL。jsessionid就会传回到Web Server。2)cookie 管理
1、用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，记录在Redis中的Key称为Session ID； 
2、服务器返回的响应报文的Set-Cookie首部字段包含了这个Session ID，客户端收到响应报文之后将该Cookie值存入浏览器中； 
3、客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID，从Redis中取出用户信息，继续之前的业务操作。

浏览器禁用 Cookie 
此时无法使用Cookie来保存用户信息，只能使用 Session。除此之外，不能再将Session ID存放到Cookie 中，而是使用URL重写技术，将Session ID作为URL的参数进行传递。

cookie与session的选择：
1、Cookie只能存储 ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session； 
2、Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie中，可以将Cookie值进行加密，然后在服务器进行解密； 
3、session存储在服务器端。对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session中。

* 缓存：
1、客户端缓存(浏览器缓存)
2、代理服务器缓存
通过通用首部cache-control控制缓存：
no-store 禁止缓存 no-cache 强制确认缓存有效期 private私有缓存(单独用户使用) public 公共缓存 Etag：缓存验证 max-age：过期机制

* 内容协商：通过内容协商返回合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面
1.服务器驱动：客户端设置ACCEPT-Language,服务器返回特定资源
2、代理服务器驱动
vary：Accpet-Language
在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

* 范围请求：如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。
1.Range: bytes = 0-1023 请求成功的话服务器返回响应206 partial content状态码
2、Accept-Ranges：告知客户端是否能处理范围请求 可以使用bytes，否则使用none
3、在请求成功的情况下，服务器会返回 206 Partial Content 状态码。在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisﬁable状态码。在不支持范围请求的情况下，服务器会返回 200 OK 状态码。

* 通信数据转发：
1、代理
代理不修改请求URI，直接发送给源服务器
使用目的：缓存/负载均衡/网络访问控制/访问日志记录
正向代理/反向代理
用户察觉得到的是正向代理
反向代理位于内部网络中，用户察觉不到
2、网关：
网关服务器会将HTTP转化为其它协议进行通信，从而请求其它非HTTP服务器的服务。利用网关可以提高通信安全。客户端与网关之间的通信线路上可以加密(网关可以连结数据库查证)。
3、隧道
使用SSL等加密手段，在客户端和服务器之间建立一条安全的通信线路。 
HTTP的缺点：
1、通信使用明文，不安全(窃听)
2、不验证通信方的身份(伪装)
3、无法证明报文完整性(篡改)

* HTTPS：
1、通信加密。通过与SSL和TLS的组合使用加密HTTP通信内容(使用了隧道进行通信)
2、验证通信方身份 使用SSL查证对方的数字证书
3、完整性保护

加密：
1、共享密钥加密 无法安全传输密钥/快
2、公开密钥加密 计算量大/安全 公开密钥加密 公钥和私钥来解密
HTTPS混合使用两种加密方式。用公开密钥加密方式交换稍后共享密钥加密中的密钥。确保安全交换密钥后，用共享密钥加密方式进行通信。
认证：
通过使用数字证书来对通信方进行认证。进行HTTPS通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先对数字签名进行验证， 如果验证通过，使用公开密钥开始通信了。(数字证书认证机构的公钥已事先植入到浏览器)
HTTPS的缺点：
1、通信上加了SSL的通信负担2、SSL的加密解密运算需要硬件资源3、需要支付数字证书的开销 
* HTTP2.0：
1、一条TCP连接只能发送一个请求  HTTP2.0支持多路复用，同时发送多个请求
2、请求只能从客户端开始，不支持服务器推送功能。HTTP/2.0在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。 
3、请求/响应首部未压缩，导致首部开销过大。HTTP/2.0要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP/2.0 也使用 Huﬀman编码对首部字段进行压缩。

* GET/POST
作用
GET 用于获取资源，而 POST 用于传输实体主体。
参数 
GET 和 POST 的请求都能使用额外的参数，但是GET的参数是以查询字符串出现在URL中，而POST的参数存储在实体主体中。
因为URL只支持ASCII码，POST参数支持标准字符集。
安全
安全的HTTP方法不会改变服务器状态，也就是说只读的。 GET方法是安全的，而 POST却不是，因为POST的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
幂等：
幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样。GET幂等，POST不幂等。
缓存：
GET响应可缓存，post响应多数情况不可缓存

http长连接区分多个请求：
Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。如果请求的是动态数据，使用Transfer-Encoding：chunked分块传输。当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。

* HTTP协议 
* HTTP和HTTP2的了解
* http的请求和应答协议报文的内容    
* 状态码有哪些，206了解吗    
* get和post的区别    
* http catch了解吗
* HTTP协议与HTTPS协议 
* HTTPS怎么实现加密 
* 长连接与短连接
* http复用连接 如何区分请求？

## HTTP方法
get:获取资源 head:获取报文首部 post：传输实体主体 put:上传文件
options:查询支持方法 connect：要求在与代理服务器通信时建立隧道
trace：追踪路径
## 状态码
1XX Informational（信息性状态码） 接收的请求正在处理
2XX Success（成功状态码） 请求正常处理完毕
3XX Redirection（重定向状态码） 需要进行附加操作以完成请求
4XX Client Error（客户端错误状态码） 服务器无法处理请求
5XX Server Error（服务器错误状态码） 服务器处理请求出错

2XX 成功 
204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 
206 Partial Content ：表示客户端进行了范围请求，服务器成功执行了这部分get请求。响应报文包含由 Content-Range 指定范围的实体内容。
3XX 重定向 
303 明确要求客户端应该采用GET方法获取资源/307不允许post变Get 
304 Not Modiﬁed ：如果请求报文附带条件，例如：If-Match，If-Modiﬁed-Since，If-NoneMatch，If-Range，If-Unmodiﬁed-Since，如果不满足条件，则服务器会返回 304 状态码。服务端资源未改变，可使用客户端未过期的缓存 
4XX 客户端错误 
400 Bad Request ：请求报文中存在语法错误。 
401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 
403 Forbidden ：请求被拒绝。 
404 Not Found
5XX 服务器错误 
500 Internal Server Error ：服务器正在执行请求时发生错误。
503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 

## 首部字段
* 通用首部字段
Cache-Control 控制缓存的行为
Connection 控制不再转发给代理的首部字段、管理持久连接 connection:close 服务端想断开时 connection: 不再转发的首部字段名
Trailer 报文末端的首部一览
Upgrade 升级为其他协议
Via 代理服务器的相关信息

* 请求首部字段
Accept 用户代理可处理的媒体类型
Accept-Charset 优先的字符集
Accept-Encoding 优先的内容编码
Accept-Language 优先的语言（自然语言）
Authorization Web 认证信息
Host 请求资源所在主机名。一台物理服务器搭建多个web站点，可以使用虚拟主机寄存多个不同主机名和域名的的web网站。虚拟主机对应同一个IP，发送HTTP请求时需要在首部字段Host完整指定主机名或域名加以区分。Host是HTTP1.1唯一一个必须在请求中的首部字段。

条件请求：
If-Match 比较实体标记（ETag）
If-Modiﬁed-Since 比较资源的更新时间
If-None-Match 比较实体标记（与 If-Match 相反）
If-Range 资源未更新时发送实体Byte的范围请求，否则返回全部资源
If-Unmodiﬁed-Since 比较资源的更新时间（与 If-Modiﬁed-Since 相反）
Max-Forwards 大传输逐跳数
Proxy-Authorization 代理服务器要求客户端的认证信息
Range 实体的字节范围请求，告知服务器资源的指定范围
Referer 对请求中URI的原始获取方
User-Agent HTTP客户端程序的信息

* 响应首部字段：
Accept-Ranges 是否接受字节范围请求 bytes(可处理范围请求) none(不可处理范围请求)
Age 推算资源创建经过时间
ETag 资源的匹配信息
Location 令客户端重定向至指定URI
Proxy-Authenticate 代理服务器对客户端的认证信息
Retry-After 对再次发起请求的时机要求 配合503告知客户端多久后在发送请求
Server HTTP服务器的安装信息
Vary：对缓存控制。对vary指定项，仅对请求中含有相同vary指定首部字段的请求返回缓存。即使对相同资源发起请求，但vary指定字段不同，也要从源服务器重新获取资源
WWW-Authenticate 服务器对客户端的认证信息

* 实体首部字段
 