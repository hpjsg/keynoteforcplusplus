TCP连接则由ngx_connection_t结构体表示，HTTP请求毫无疑问是基于一个TCP连接实现的。每个TCP连接包括一个读事件和一个写 事件，它们放在ngx_connection_t中的read成员和write成员中。通过事件模块提供的 ngx_handle_read_event方法和ngx_handle_write_event方法，可以把相应的事件添加到epoll中， 我们可以期待在满足事件触发条件时，Nginx进程会调用ngx_event_t事件的handler回调方法执 行业务。而通过事件模块提供的ngx_add_timer方法可以将上面的读事件或者写事件添加到定 时器中，在满足超时条件后，Nginx进程同样会调用ngx_event_t事件的handler回调方法执行业
务。

1将新建立连接c的read读事件的handler方法设为 ngx_http_init_request，默认可写事件的回调函数为什么都不做的ngx_http_empty_handler
2如果这个连接对应的套接字缓存上已经有用户发来的数据，这时就可调用上面说过的ngx_http_init_request方法处理请求
3否则调用ngx_add_timer方法把读事件添加到定时器中，如果经过client_header_timeout时间后这个连接上还没有用户数据到达，则会由定时器触发调用读事件的ngx_http_init_request处理方法。
4可读事件添加到epoll


当TCP连接上第一次出现可读事件时，将会调用ngx_http_init_request方法初始化这个HTTP请求，当连接对应的套接字缓冲区上确实接收到了用户发来的请求内容时才进行初始化请求，当有些客户端建立起TCP连接后一直没有发送内容时，Nginx是不会为它分配内存的。


首先要检查读事件是否已经超时(定时器触发读事件)，超时则调用ngx_http_close_request方法关闭请求后返回。
对请求构造 ngx_http_request_t 结构体并初始化部分参数、修改读事件的回调方法为ngx_http_process_request_line 并调用该方法开始接收并解析HTTP请求行。

请求行长度是不定的，与URI长度相关，这意味着在读事件被触发时，内核套接字缓冲区的大小未必足够接收到全部的HTTP请求行，调用一次ngx_http_process_request_line方法不一定能够做完这项工作。所以，ngx_http_process_request_line方法也会作为读事件的回调方法，可能会被epoll这个事件驱动机制多次调度，反复地接收TCP流并使用使用状态机解析已接受到的字符流，确认其是否构成完整的HTTP请求行。在接收到完整的HTTP请求行后，首先要把请求行中的信息如方法名、URI及其参数、HTTP版本等信息设置到ngx_http_request_t结构体的相应成员中这时把读事件的回调方法由ngx_http_process_request_line改为ngx_http_process_request_headers，准备接收HTTP头部。
调用ngx_http_process_request_headers方法开始接收HTTP头部。

HTTP头部也属于可变长度的字符串，它与HTTP请求行和包体间都是通过换行符来区分的。同时，它与解析HTTP请求行一样，都需要使用状态机来解析数据。首先检查当前的读事件是否已经超时。接收请求已经超时，调用 ngx_http_close_request方法关闭连接。接收并解析出全部的HTTP头部，同时检查它们的合法性，并将解 析出的HTTP头部设置到ngx_http_request_t结构体里的合适位置。这时调用ngx_http_process_request方法开始使用各HTTP模块正式地在业务上处理HTTP请求。

不存在接受http请求头部超时，从定时器中把当前读事件移除。重新设置当前连接的读写事件的回调方法，ngx_request_handler用于请求的后续处理。




#include <> 会先去编译器环境下查找, 找不到再去系统默认目录下查找标准库文件
#include "" 会先在用户的工作目录中查找, 找不到再搜索#include<>中。 自己编写的头文件
 
指针/引用：
指针是一个实体，需要分配内存空间/引用是别名，不占用内存空间
指针的值可以改变/引用在定义时被初始化，且只能被初始化一次。
指针有多级/应用只有一级
指针本身包含了对象的地址，对指针的直接操作都是对地址的操作，*解除引用才是对被引用的对象的操作/引用只能对被引用对象操作
作为参数时也不同，传指针的实质是传值，传递的值是指针的值；传引用的实质是传地址，传递的是变量的地址。

静态变量初始化：
C中静态变量在主程序之前初始化。
C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序相反进行逐个析构

如果需要在const成员函数中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable
extern 1)extern修饰变量的声明。如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。
2)	extern修饰函数的声明
3)	extern修饰符可用于指示C或者C＋＋函数的调用规范。C++中调用C库函数 extern “C”

文件中定义的全局变量的可见性扩展到整个程序是在链接完成之后，而在编译阶段，他们的可见性仍局限于各自的文件。就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件或本文件当前位置中定义，但是它是在别的文件中或本文件其它位置定义的全局变量。

int和string之间的转换
to_string(int)
std::stoi//stol//stoll
c风格字符串atoi
int 转c风格字符串 sprintf

C语言中，struct只是一个聚合数据类型
c++中struct可以定义成员函数，可以继承，能实现多态。
c++中struct可以设置数据访问权限，可以隐藏数据。
struct默认访问权限为public，class的默认访问权限为private

* 类成员初始化：
对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
列表初始化是给数据成员分配内存空间时就进行初始化，函数体还未执行。

初始化列表的初始化顺序是按照声明顺序，和列表中的顺序无关。

在<初始化列表>中，对象进行构造。分配空间，在初始化列表中的数据成员并进行初始化。
在<构造函数体>开始执行前，对象内存分配完毕，所有成员对象的构造函数也已经执行完毕。
构造函数执行过程中，对象的数据还没准备好，但在语法层面上，this指针已经可用。

派生类构造函数调用顺序：
虚拟基类的构造函数
基类的构造函数。
类类型的成员对象的构造函数
派生类自己的构造函数。

析构相反。

类只允许动态分配/只允许静态分配：
构造、析构函数设为protected属性，再用子类来动态创建(不能外部调用，子类内部可以调用) /把new、delete运算符重载为private属性

什么情况生成默认构造函数：
1、有具有默认构造函数的类成员对象。
2、有默认构造函数的基类。
3、有虚函数。
4、有虚基类。

包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

1)	向上类型转换
将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。
2)	向下类型转换
将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。


在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。C++11中右值又分为纯右值和将亡值。纯右值是临时变量和不和对象关联的字面量。将亡值是将要被移动的的对象。
左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，右值通常不具有名字，我们也只能通过引用的方式找到它的存在。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。
要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为将亡值。


拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。只有用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。

预处理->编译->汇编->链接
对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。
词法分析和语法分析，生成中间代码表示或汇编代码
汇编语言代码翻译成目标机器指令的过程 -obj文件
有关的目标文件彼此相连接 - 可执行文件


c/c++
1、面向过程/面向对象(封装/继承/多态)
2、动态管理内存的方法不同 malloc/free / new/delete
3、C struct C语言中，struct只是一个聚合数据类型 / C++ struct && class
4、不支持函数重载/支持函数重载 C++的名字修饰与C不同，int fun(int ,int)经过名字修饰之后变为 _fun_int_int 而c是_fun
5、	C++中有引用，而C没有
6、C++特有输入输出流之类

野指针：
指向无效内存或没有权限访问的内存
1、指针变量没有被初始化
2、指针被free或者delete之后，没有置为NULL(悬空指针)
3、指针操作超越了变量的作用范围

悬空指针 指针指向对象被析构

 new []一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了4个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。指针p指向new[]分配的内存。因为要4字节存储数组大小n，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存，调用n次析构函数。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，只调用一次析构函数。


const/#define/inline/typedef
1、const定义的是变量是常量带类型，而#define定义的只是个常数不带类型
2、define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；
3、define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；
4、define预处理后，占用代码段空间，const占用数据段空间；
5、	define独特功能，比如可以用来防止文件重复引用

2、typedef在编译阶段有效
3、typedef有类型检查的功能
4、typedef用来定义类型的别名，定义与平台无关的数据类型/#define不只是可以为类型取别名，还可以定义常量、变量
5 #define没有作用域的限制，typedef有作用域限制

1、	#define是关键字，inline是函数
2、	宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换
3、	inline函数有类型检查，相比宏定义比较安全

函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定

模板仅在需要的时候才会实例化，编译器只看到模板的声明时，它不能实例化该模板。编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现。编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找。

static_cast: 在隐式转换时有时编译器会有警告信息，但是显示转换(使用static_cast)就不会有。static_cast还会进行一些基础的类型检查，能在编译期发现错误。
reinterpret_cast:数据的二进制格式重新解释，它依赖机器
dynamic_cast: 继承体系中的安全向下转换。指向基类的指针转型为指向子类的指针或引用。会动用运行时信息（RTTI）来进行类型安全检查。被转换的类型必须是多态（即有虚函数）
const_cast：去除或添加const特性

#ifdef endif:
1、条件编译。源文件中的一部分内容只在满足一定条件才进行编译。
2、避免头文件重定义。多个文件同时包含一个头文件。当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。

多重继承：（优点）对象可以调用多个基类中的接口。（缺点）多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。

union结构式一种特殊的类。它能够包含访问权限、成员变量、成员函数（可以包含构造函数和析构函数）。它不能包含虚函数和静态数据变量。它也不能继承或被继承。Union中得默认访问权限是public。union类型是共享内存的，以size最大的成员作为自己的大小。每个数据成员在内存中的起始地址是相同的。


虚基类的构造函数先于非虚基类的构造函数执行，析构最后。
析构函数：
析构函数函数体被执行；
如果拥有成员类对象，而后者拥有析构函数，那么它们会以其声明顺序的相反顺序被调用；
如果对象有一个vptr，现在被重新定义
非虚基类拥有析构函数，则它们会以声明顺序被调用；
虚基类析构函数

strlen 不包括字符串结尾的0，返回字符个数
sizeof 字节数

参数传引用：
1、不需要实参拷贝给形参(值传递)。
2、修改形参就是修改实参
3、引用可读性更好（比传指针）

float 判断是否等于0
fabs(a)<1e-6 小数六位以后是不精确的，是没有意义

数组名和指针的区别：
1、数组名取地址得到的是数组首地址。 对指针取地址得到的是指针变量自身的地址。
2、数组名是不允许更改的，而指针可以更改。 
3、使用sizeof时，得到的是数组元素总共占用字节数，对指针sizeof得到的是指针类型的字节数


1、浏览器地址栏输入url

2、浏览器会先查看浏览器缓存--系统缓存--路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步

3、域名解析（DNS）获取相应的ip

4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手

5、握手成功，浏览器向服务器发送http请求，请求数据包

6、服务器请求数据，将数据返回到浏览器

7、浏览器接收响应，读取页面内容，解析html源码


进程：1、程序一次动态执行，是动态概念，程序是一种静态概念。
2、一个进程可以执行一个或几个程序，同一个程序可由几个进程执行

死锁：
1、互斥条件
2、不可抢占条件
3、占有且申请条件
4、循环等待条件

死锁避免：银行家算法：基本思想是分配资源之前，判断分配后系统状态是否是安全的；若是，才分配。并非所有的不安全状态都是死锁，但是处于不安全状态很可能产生死锁
找到一条安全执行序列：
系统试分配资源后，算法从现有进程列表寻找出一个可执行的进程进行执行，执行完 成后回收进程占用资源；进而寻找下一个可执行进程。当进程需求量大于系统可分配量时，进程无法执行。当所有进程均可执行，则产生一个安全执行序列，系统资源分配成功。找不到一条安全执行序列时，执行失败。


多线程同步：
1、mutex 互斥锁对象 2、信号量 sem_get sem_op sem_ctl 3、条件变量 4、自旋锁 5、读写锁 6、seq锁 

守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

系统调用/函数调用：函数调用运行在用户空间，通过压栈来进行函数调用。 /系统调用运行在内核空间，涉及用户空间和内核空间的上下文环境切换(处理器信息/栈信息/寄存器信息)

虚拟内存：
它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
1、可以弥补物理内存的不足。
2、进程的虚拟地址空间

内存碎片：
1、固定式分区分配中存在内碎片，可变式分区分配中存在外碎片(分区大小动态变化，首先适配、最佳适配、最差适配、下一次适配)。
2、伙伴系统（有效解决外碎片）。
内核将页分为:
不可移动页：这些页在内存中有固定的位置，不能够移动。
可回收页：这些页不能移动，但可以删除。内核在回收页占据了太多的内存时或者内存短缺时进行页面回收。
可移动页：这些页可以任意移动，用户空间应用程序使用的页都属于该类别。它们是通过页表映射的。当它们移动到新的位置，页表项也会相应的更新。

I/O 控制方式：
1、直接I/O(轮询)
2、中断
3、DMA(直接主存存取方式,不占用CPU)


软连接/硬链接
硬链接(hard link)：实体链接。A是B的硬链接（A和B都是文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。
软链接(soft link)：符号链接。A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项，B如果移动，A就无效了，硬链接就不会）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。



TCP 定时器：
1、重传定时器：定时器超时未收到对报文段的确认，重传报文段，定时器复位。
2、坚持计时器：发送端收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器到时，发送端就发送一个探测报文段。(因为窗口通告是不可靠的，用于获得窗口通告)
3、keep-alive计时器：探测客户端是否退出、异常退出。
4、time-wait计时器：2MSL

recv/send     read/write
1、recv、send只用于套接字通信；
2、read、write是底层系统调用，只要是文件操作就都可以用
3、recv、send 提供了flags参数，控制读写操作。flags为0时，与read/write功能相同。


设计模式：
1、单例：懒汉/饿汉
懒汉式单例模式在类加载时不初始化，饿汉式单例模式，在类加载时就完成初始化，所以类加载较慢，但获取单例的对象速度快。
线程安全的单例模式：
懒汉：
pthread_once
内部静态局部对象
DCL双检锁 执行时由于指令乱序会出现问题
饿汉模式线程安全

如何判断是当前线程？
compare_exchange_strong
circular_buffer的阻塞，锁。

reactor 和 proactor的区别：
1、reactor模式，是同步IO模式。proactor模式，是异步IO模式。
最主要的区别是真正的IO操作是由谁来完成。二者都是事件多路的分离器和事件处理器组成。
Reactor模式，事件分离器负责等待文件描述符准备就绪，然后将就绪事件传递给对应的处理器，最后由事件处理器负责完成实际的读写工作。
Proactor模式，处理器只负责发起异步读写操作。IO操作本身由操作系统来完成。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。
proactor的缺点：
1、编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。
2、内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比Reactor模型，在Socket已经准备好读或写前，是不要求开辟缓存的；
3、操作系统支持，Windows下通过IOCP实现了真正的异步I/O，而在Linux系统下，Linux2.6才引入，并且异步I/O使用epoll实现的，所以还不完善。




